\documentclass[a4paper,10pt]{article}

\title{How do I code?}
\author{Student Robotics}

\begin{document}

\maketitle

\hfill ``I don't know how to program!''\\
% Create a box for hfill space to get stuck to
\hphantom{fgasdf}\hfill --- Many SR competitors\\
\\
``Everyone can program!''\\
--- Many other people\\

\section{Introduction}

This is a guide on how to go about programming your robot, as part of the
Student Robotics competition. Writing the \textit{text} of your program is
covered elsewhere, for example the Python
tour\footnote{https://www.studentrobotics.org/docs/tutorials/python} --- this
guide is about how to \textit{design} your program. We only assume that you
know four things:
\begin{enumerate}
	\item Variables and assignment
	\item Conditionals (``if'' statements)
	\item Loops
	\item Functions
\end{enumerate}
All of which are covered by the Python tour.

Programming can be difficult, but at the same time a lot of people say that
programming is easy!\footnote{https://code.org/} The difference is that it is
easy to learn the building blocks of programming, but much more challenging to
put them together into a large system. Think of juggling: we can all juggle
a single ball, but every extra ball makes the task substantially more
difficult, and once you start juggling different kinds of objects it gets
even worse.

Programming a robot is similar to juggling: if you know your robot is in one
place and has certain things in front of it, it's easy to tell it what to do.
If you don't know what's in front of it, correctly programming your robot
becomes more difficult. That gets worse if you don't know it's location, and
much much worse if there are other robots that may get in the way. If you
consider all the locations that your robot, the arena tokens\footnote{Or other
arena items, depending on what the competition game is}, and other robots
may be in, there are thousands of different possibilities. Correctly handling
all of these possibilities is not a simple task.

Happily, there is a programming technique called a \textit{state machine} that
is well suited to dealing with these problems. It won't tell you what decisions
your robot should take, but it \textit{will} make it simple to write a program
that makes those decisions, and can handle those thousands of possibilities.
State machines are very popular --- your average smartphone will contain
tens of thousands of hardware and software state machines.

In the rest of this guide, we will look at
\begin{itemize}
	\item What is the aim of your robot program
	\item What is a state machine?
	\item An example state machine
	\item How to make robust programs
	\item XXX more?
\end{itemize}

\section{What does your robot program do?}

In Student Robotics, you will have been given a game for the robot to play, as
defined in this years rulebook. The aim is to score the highest number of
points, by performing some kind of task in the arena. If we were to put
\textit{you}, a human, into the arena to perform this task, you would decide
how best to score points and then move around the arena doing the actions that
score points, reacting to what is in front of you and what the other
participants are doing.

Your robot, however, does not have the ability to do all those things. Because
it is almost impossible to make your robot read and understand the rulebook,
you will have to first decide a strategy for scoring points, and then make a
robot program that implements that strategy. The former is your teams problem,
the latter is what this guide is about.

Let's look closer at how humans go about performing the task. For everything
that we do, you can identify three main parts:
\begin{enumerate}
	\item We \textit{look} around the arena and work out what's in front of us
	\item Using the point scoring strategy, we \textit{decide} what action is best to score points
	\item We \textit{perform} the action
\end{enumerate}

We can replicate this decision process in a robot program pretty accurately:
\textit{looking} around the arena corresponds to inputs from your robots webcam
and sensors, gathering information about the environment. \textit{Deciding} is
the operation of your robot program, using the input data. \textit{Performing}
an action means operating robot outputs, such as motors, servos, or anything
else you hook up to your robot. Lets consider a simple robot decision process:

XXX insert here diagram of a robot doing something, currently in my logbook

\begin{enumerate}
\item Mission statement of the robot
\item Replicates decision process
\item Illustrate example motions / arena path / whatever
\item What's available to achieve this are inputs / outputs
\item As we discussed, state space is huge
\item What you want is a small program that achieves this all, and:
\begin{itemize}
	\item Can be well understood by the reader
	\item Can be easily modified to do something different
	\item Is robust (against unexpected things happening)
\end{itemize}
\end{enumerate}

\section{Design patterns and state machines}
\begin{enumerate}
\item Programmers re-use lots of things. So should you.
\item \textit{Design patterns} exist: common ways of thinking about things
\item In the context of robotics, the \textit{state machine} is the most common
\item There are thousands in your phone
\item They have some exellent attributes:
\begin{itemize}
	\item Very limited number of states
	\item Clear reasons for a decision being made
	\item Easy to debug.
	\item You can compose them
\end{itemize}
\item High level view of what states and transitions may be
\end{enumerate}

\section{A simple example}
\begin{enumerate}
\item Formally show some states and transitions
\item Say that we're going to make a state machine for the example path above
\item Do so
\item Illustrate path with states / transitions, actually draw dot file?
\item Show example code (python), explain syntax isn't important
\end{enumerate}

\section{Making it robust}
\begin{enumerate}
\item Self loops if things go wrong
\item Think about valid error states and what to do
\item Now consider full state space: what would you do?
\item Ideally you consider all cases; just try for good coverage though
\item Good code practice (functions etc)
\end{enumerate}

\section{Inputs and outputs}
\begin{enumerate}
\item Identify loop cycle of a state machine
\item Read inputs and states, decide outputs, wait time, repeat
\item Not sure what else
\end{enumerate}

\section{Summary}
fgasdf
\end{document}
